Computer Science quiz 1

1) What is a data structure?
>>> A) An abstract template to organize data
B) A type of database that stores data used by software
C) A series of functions used to manipulate data
D) None of the above

EXPLANATION
A data structure is an abstract template that organizes data in a way that helps to simplify sorting, searching, computing and other operations.

Covered in: Introduction to Data Structures


2) Why do engineers need to use data structures when writing software?
A) To provide a logical workflow to test and debug code 
>>> B) To organize data for easier use and manipulation
C) To improve the performance and efficiency of code
D) None of the above

EXPLANATION
Engineers use data structures to define the most appropriate ways to store and manipulate data required in the software.

Covered in: Introduction to Data Structures

3) Which of the following statements is false?
A) Classes belong to object-oriented languages.
B) Classes are a type of data structure.
>>> C) Data structures must be implemented using classes.
D) All of the above.

EXPLANATION
Although classes are a type of data structure, they are not necessary. Classes belong to object-oriented languages. Although not all languages are object-oriented, most are still able to support the creation of abstract data structures.

Covered in: Introduction to Data Structures

4) Which of the following is an example of a data structure that can be used to store a collection of names?

>>> A) Array
B) String
C) Number
D) All of the above

EXPLANATION
Arrays are used to store data in a sequence, one element after another. By combining the location of the data and the ability to recover any element by using an index, the array simplifies access to and manipulation of ordered elements. Arrays are a good choice for collections of simple data types such as strings, numbers, etc.

Covered in: Introduction to Data Structures

Computer Science - Algorithm/Time Complexity Basics

1) Which of these statements does not describe an algorithm?

A) An algorithm is a sequence of steps.
>>> B) An algorithm must be efficient.
C) An algorithm must complete in a finite amount of time.
D) An algorithm is a solution for a specific task.

EXPLANATION
An algorithm is a sequence of logical steps designed to complete a particular task in a finite amount of time. It doesn’t matter if an algorithm is slow or inefficient as long as it still abides by the other three properties.

Covered in: Algorithms: Introduction

2) What is time complexity?

A) The number of loops that an algorithm contains.
B) The method of finding an algorithm’s efficiency.
C) The physical time duration of an algorithm.
>>> D) A function that estimates the time an algorithm takes to run.

EXPLANATION
We write time complexity as a function which approximates the time duration of an algorithm given an input of size n. This way, the behavior of the function can be determined when given a close to infinite input.

Covered in: Time Complexity Basics

3) Is runtime the same as time complexity?

A) Yes, but it can also refer to the number of instructions in an algorithm.
>>> B) Yes, but it can also refer to the physical time duration of an algorithm.
C) No, it is only the physical time duration of an algorithm.
D) No, it is only the number of instructions in an 'algorithm.

EXPLANATION
We often use time complexity and runtime interchangeably. However, the runtime can also refer to the physical duration a particular algorithm takes to run at a given time.

Covered in: Time Complexity Basics

4) What is not part of determining the time complexity of an algorithm?

A) The size of the input.
B) Considering the worst case scenario.
>>> C) Counting the number of parameters a function takes.
D) Counting the number of instructions in the algorithm.

EXPLANATION
The number of parameters doesn’t matter when considering the time complexity of an algorithm. Even if there is more than one parameter, complexity is only concerned with how the function acts as all parameters become infinitely large.

Covered in: Time Complexity Basics

5) If an algorithm has linear growth does it:

A) Always takes the same amount of time to run.
B) Increase in runtime quickly for small input and taper off.
C) Continue to increase at runtime faster than the input size increases.
>>> D) None of the above.

EXPLANATION
The three answers described here are constant, logarithmic, and quadratic (or possibly exponential) time. Linear growth implies that the runtime grows in direct relation to the size of the input.

Covered in: Time Complexity Basics

6) In what way might the choice of algorithm make a difference?

A) One solution may be more efficient than another.
B) One solution may apply to other scenarios more easily.
>>> C) Both of these.
D) Neither of these.

EXPLANATION
All algorithms are not equally fast or useful. There are multiple solutions to most problems, and one algorithm may run faster on a regular basis. In other cases, one algorithm may be applied to multiple situations, like the bow tie example, in which the bow, in addition to the shoelace, may be appropriate to wrap a gift but a surgeon’s knot would not be. If a solution may need to be more broadly applied, one algorithm may be more suited to the task than another.

Covered in: Algorithms: Introduction


7) What is the time complexity of the following algorithm?

```
FUNCTION FindSmallFactors(n)
    FOR i in 2 to 7
        IF n / i has no remainder THEN
            PRINT i + “ is a factor of ” + n
        END IF
    END FOR
END FUNCTION
```
 
A) Linear
>>> B) Constant
C) Logarithmic
D) Quadratic

EXPLANATION
Even though this algorithm contains a loop, which often indicates linear growth, the loop itself is not dependent on the input and only runs a set amount of instructions.

Covered in: Time Complexity Basics

8) When evaluating three different functions, you have found that one function has n + 1 instructions, a second has 2n instructions, and a third has n log n instructions. List the functions in order of efficiency.

>>> A) Both the n + 1 and 2n functions are equally efficient, and the n log n function is less efficient.
B) The n log n function is the most efficient and both the n + 1 and 2n functions are equally but less efficient.
C) The function with n + 1 instructions is the most efficient, followed by 2n, and n log n is last.
D) The linear function with n + 1 instructions is the most efficient, followed by n log n, and the 2n function is last.